#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 27 11:31:49 2019

Basic version of ldscsim:
    annotation-informed model takes only the field of aggregated annotations
    adding population stratification takes only the field of aggregated covariates 

@author: nbaya
"""

import hail as hl
from hail import dtype
from hail.typecheck import typecheck, oneof, nullable
from hail.expr.expressions import expr_float64, expr_int32, expr_array 
from hail.matrixtable import MatrixTable
from hail.utils.java import Env
import numpy as np
import pandas as pd
import random
import string

@typecheck(mt=MatrixTable, 
           genotype=oneof(expr_int32,
                          expr_float64),
           h2=nullable(oneof(float,
                             int,
                             list)),
           pi=nullable(oneof(float,
                             int)),
           rg=nullable(oneof(float,
                             int,
                             list)),
           annot=nullable(oneof(expr_float64,
                                expr_int32)),
           popstrat=nullable(oneof(expr_int32,
                                   expr_float64)))
def simulate_phenotypes(mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None):
    r'''Simulate phenotypes for testing LD score regression.
    
    Simulates betas (SNP effects) under the infinitesimal, spike & slab, or 
    annotation-informed models, depending on parameters passed. Optionally adds
    population stratification.
    
    Parameters
    ----------
    mt : :class:`.MatrixTable`
        MatrixTable containing genotypes to be used. Also should contain 
        variant annotations as row fields if running the annotation-informed
        model or covariates as column fields if adding population stratification.
    genotype : :class:`.Expression`
        Entry field containing genotypes of individuals to be used for the
        simulation.
    h2 : :obj:`float` or :obj:`int` or :obj:`list`
        Heritability of simulated trait. Can only be None if running annotation-
        informed model.
    pi : :obj:`float` or :obj:`int`
        Probability of SNP being causal when simulating under the spike & slab 
        model.
    rg : :obj:`float` or :obj:`int` or :obj:`list`
        Genetic correlation between traits.
    annot : :class:`.Expression`
        Row field to use as our aggregated annotations.
    popstrat: :class:`.Expression`
        Column field to use as our aggregated covariates for adding population
        stratification.
    
    Returns
    -------
    :class:`.MatrixTable`
        MatrixTable with simulated betas and phenotypes, simulated according
        to user-specified model.
        '''
    tid = ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase, k=5)) # "temporary id" -- random string to identify temporary intermediate fields generated by this method
    mt = annotate_all(mt=mt,
                      row_exprs={} if annot is None else {'annot_'+tid:annot},
                      col_exprs={} if popstrat is None else {'popstrat_'+tid:popstrat},
                      entry_exprs={'gt_'+tid:genotype},
                      global_exprs={'ldscsim':hl.struct(**{**{'h2':h2},
                                                           **({} if pi is None else {'pi':pi}),
                                                           **({} if rg is None else {'rg':rg}),
                                                           **({} if annot is None else {'is_annot_inf':True}),
                                                           **({} if popstrat is None else {'is_popstrat_inf':True})
                                                           })})
    mt = make_betas(mt=mt, 
                    h2=h2, 
                    pi=1 if pi is None else pi, 
                    annot=None if annot is None else mt['annot_'+tid],
                    rg=rg)
    mt = calculate_phenotypes(mt=mt, 
                              genotype=mt['gt_'+tid], 
                              beta=mt['beta'],
                              h2 = h2,
                              popstrat=None if popstrat is None else mt['popstrat_'+tid])
    mt = clean_fields(mt, tid)
    return mt
    
@typecheck(mt=MatrixTable, 
           h2=nullable(oneof(float,
                             int,
                             list)),
           pi=oneof(float,int),
           annot=nullable(oneof(expr_float64,
                                expr_int32)),
           rg=nullable(oneof(float,
                             int,
                             list)))
def make_betas(mt, h2, pi=1, annot=None, rg=None):
    '''Generates betas under different models: 
            - Infinitesimal
            - Spike & Slab
            - Annotation-Informed
    '''
    h2 = [h2] if type(h2) is not list else h2
    pi = [pi] if type(pi) is not list else pi
    rg = [rg] if type(rg) is not list else rg
    assert (all(x >= 0 and x <= 1 for x in h2)), 'h2 values must be between 0 and 1'
    assert (all(x >= 0 and x <= 1 for x in pi)), 'pi values for spike & slab must be between 0 and 1'
    M = mt.count_rows()
    if annot != None: #annotation-informed
        mt = mt.annotate_rows(**{'beta': hl.rand_norm(0, hl.sqrt(annot))}) # if is_h2_normalized: scale variance of betas to be h2, else: keep unscaled variance
        return mt
    elif len(h2)>1: #multi-trait infinitesimal
        return multitrait_betas(mt=mt,h2=h2,rg=rg)
    else: #infinitesimal/spike & slab
        return mt.annotate_rows(beta = hl.rand_bool(pi)*hl.rand_norm(0,hl.sqrt(h2[0]/(M*pi[0]))))
        
@typecheck(mt=MatrixTable, 
           h2=nullable(oneof(float,
                             int,
                             list)),
           rg=nullable(oneof(float,
                             int,
                             list)),
           cov_array=nullable(np.ndarray),
           seed=nullable(int))
def multitrait_betas(mt, h2=None, rg=None, cov_array=None, seed=None):
    '''Generates correlated betas for multi-trait simulations'''
    h2 = [h2] if type(h2) is not list else h2
    rg = [rg] if type(rg) is not list else rg
    seed = seed if seed is not None else int(str(Env.next_seed())[:8])
    assert (all(x >= 0 and x <= 1 for x in h2)), 'h2 values must be between 0 and 1'
    M = mt.count_rows()
    if cov_array != None:
        n_phens = cov_array.shape[0]
    else:
        n_phens = len(h2)
        if rg == [None]:
            print(f'Assuming rg=0 for all {n_phens} traits')
            rg = [0]*int((n_phens**2-n_phens)/2)
        assert (all(x >= -1 and x<= 1 for x in rg)), 'rg values must be between 0 and 1'
        cov_array = create_cov_array(h2, rg)
    cov_array = (1/M)*cov_array
    randstate = np.random.RandomState(int(seed)) #seed random state for replicability
    betas = randstate.multivariate_normal(mean=np.zeros(n_phens),cov=cov_array,size=[M,])
    df = pd.DataFrame([0]*M,columns=['beta'])
    tb = hl.Table.from_pandas(df)
    tb = tb.add_index().key_by('idx')
    tb = tb.annotate(beta = hl.literal(betas.tolist())[hl.int32(tb.idx)])
    mt = mt.add_row_index()
    mt = mt.annotate_rows(beta = tb[mt.row_idx]['beta'])
    return mt

@typecheck(h2_ls=list,
           rg_ls=list)
def create_cov_array(h2_ls, rg_ls):
    '''
    Creates covariance array for simulating correlated betas. h2 values in h2_ls
    should be ordered by their order in the upper triangle of the covariance
    array, reading from left to right, top to bottom. rg values should be ordered
    in the order they appear in the covariance array, from top left to bottom right.
    '''
    assert (all(x >= 0 and x <= 1 for x in h2_ls)), 'h2 values must be between 0 and 1'
    assert (all(x >= -1 and x<= 1 for x in rg_ls)), 'rg values must be between 0 and 1'
    n_rg = len(rg_ls)
    n_h2 = len(h2_ls)
    exp_n_rg = int((n_h2**2-n_h2)/2)
    if n_rg is not exp_n_rg:
        raise ValueError(f'The number of rg values given is {n_rg}, expected {exp_n_rg}')
    rg_ls = np.asarray(rg_ls)
    cov_array = np.zeros(shape=[n_h2,n_h2])
    cov_array[np.triu_indices(n_h2, k=1)] = rg_ls**2 #sets upper diagonal with covariances
    h2_diag = np.diag(h2_ls)
    cov_array = (np.matmul(np.matmul(cov_array,h2_diag).T,h2_diag)**(1/2))
    cov_array += cov_array.T + h2_diag
    return cov_array

@typecheck(mt=MatrixTable,
           genotype=expr_int32,
           beta=oneof(expr_float64,
                      expr_array(expr_float64)),
           h2=nullable(oneof(float,
                             int,
                             list)),
           popstrat=nullable(expr_int32))
def calculate_phenotypes(mt, genotype, beta, h2, popstrat=None):
    tid = ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase, k=5)) # "temporary id" -- random string to identify temporary intermediate fields generated by this method
    mt = annotate_all(mt=mt,
                      row_exprs={'beta_'+tid:beta},
                      entry_exprs={'gt_'+tid:genotype})
    mt = normalize_genotypes(mt['gt_'+tid])
    if mt['beta_'+tid].dtype == dtype('array<float64>'):
        mt = mt.annotate_cols(y_no_noise = hl.agg.array_agg(lambda beta: hl.agg.sum(beta*mt['norm_gt']),mt['beta_'+tid]))
        mt = mt.annotate_cols(y = mt.y_no_noise + hl.literal(h2).map(lambda x: hl.rand_norm(0,hl.sqrt(1-x))))
    else:
        mt = mt.annotate_cols(y_no_noise = hl.agg.sum(mt['beta_'+tid] * mt['norm_gt']))
        mt = mt.annotate_cols(y = mt.y_no_noise + hl.rand_norm(0, hl.sqrt(1-h2)))
    mt = clean_fields(mt, tid)
    return mt
    
@typecheck(genotypes=oneof(expr_int32,
                           expr_float64))
def normalize_genotypes(genotypes):
    ''''''
    tid = ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase, k=5)) # "temporary id" -- random string to identify temporary intermediate fields generated by this method
    mt = genotypes._indices.source
    mt = mt.annotate_entries(**{'gt_'+tid: genotypes})
    mt = mt.annotate_rows(**{'gt_stats_'+tid: hl.agg.stats(mt['gt_'+tid])})
    mt = mt.annotate_entries(norm_gt = (mt['gt_'+tid]-mt['gt_stats_'+tid].mean)/mt['gt_stats_'+tid].stdev)  
    mt = clean_fields(mt, tid)
    return mt

@typecheck(mt=MatrixTable,
           str_expr=str)
def clean_fields(mt, str_expr):
    '''Removes fields with names that have str_expr in them'''
    all_fields = list(mt.col)+list(mt.row)+list(mt.entry)+list(mt.globals)
    return mt.drop(*(x for x in all_fields if str_expr in x))

@typecheck(mt=MatrixTable,
           row_exprs=dict,
           col_exprs=dict,
           entry_exprs=dict,
           global_exprs=dict)
def annotate_all(mt,row_exprs={},col_exprs={},entry_exprs={},global_exprs={}):
    '''Equivalent of _annotate_all, but checks source MatrixTable of exprs'''
    exprs = {**row_exprs, **col_exprs, **entry_exprs, **global_exprs}
    for key, value in exprs.items():
        if type(value) == expr_float64 or type(value) == expr_int32:
            assert value._indices.source == mt, 'Cannot combine expressions from different source objects.'
    return mt._annotate_all(row_exprs, col_exprs, entry_exprs, global_exprs)
    
    
def check_h2(beta=None, y_no_noise=None, h2_exp=None):
    '''Check the h2 of simulated trait'''
    if beta is not None and y_no_noise is None:
        mt = beta._indices.source
        h2_obs = mt.aggregate_rows(hl.agg.stats(beta)).stdev**2*mt.count_rows()
    elif y_no_noise is not None:
        mt = y_no_noise._indices.source
        h2_obs = mt.aggregate_cols(hl.agg.stats(y_no_noise)).stdev**2
    print('' if h2_exp is None else f'\rExpected h2 from sim: {h2_exp}')
    print(f'\rObserved h2 from sim: {h2_obs}')
