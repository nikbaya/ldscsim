#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 27 11:31:49 2019

@author: nbaya
"""

import hail as hl
from hail import dtype
from hail.typecheck import typecheck, oneof, nullable
from hail.expr.expressions import expr_float64, expr_int32, expr_array 
from hail.matrixtable import MatrixTable
from hail.utils.java import Env
import numpy as np
import pandas as pd
import random
import string
#import os

def simulate_phenotypes(mt, genotype, h2, pi=1, annot=None, rg=None, popstrat=None):
    tid = ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase, k=5)) # "temporary id" -- random string to identify temporary intermediate fields generated by this method
    mt = mt.annotate_entries(**{'gt_'+tid:genotype})
    mt = make_betas(mt=mt, 
                    h2=h2, 
                    pi=pi, 
                    annot=annot,
                    rg=rg)
    mt = calculate_phenotypes(mt=mt, 
                              genotype=mt['gt_'+tid], 
                              beta=mt['beta'],
                              h2 = h2,
                              popstrat=popstrat)
    mt = clean_fields(mt, tid)
    return mt
    
@typecheck(mt=MatrixTable, 
           h2=nullable(oneof(float,
                             int,
                             list)),
           pi=oneof(float,int),
           annot=nullable(oneof(expr_float64,
                                expr_int32)),
           rg=nullable(oneof(float,
                             int,
                             list)))
def make_betas(mt, h2, pi=1, annot=None, rg=None):
    h2 = [h2] if type(h2) is not list else h2
    rg = [rg] if type(rg) is not list else rg
    tid = ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase, k=5)) # "temporary id" -- random string to identify temporary intermediate fields generated by this method
    M = mt.count_rows()
    if annot != None: #annotation-informed
        mt = mt.annotate_rows(**{'beta': hl.rand_norm(0, hl.sqrt(annot))}) # if is_h2_normalized: scale variance of betas to be h2, else: keep unscaled variance
        mt = mt.clean_fields(mt, tid)
        return mt
    elif len(h2)>1: #multi-trait infinitesimal
        return make_corr_betas(mt=mt,h2=h2,rg=rg)
    else: #infinitesimal/spike & slab
        return mt.annotate_rows(beta = hl.rand_bool(pi)*hl.rand_norm(0,hl.sqrt(h2[0]/(M*pi))))
        
def make_corr_betas(mt, h2=None, rg=None, cov_array=None, seed=None):
    '''Make correlated betas for multi-trait simulations'''
    seed = seed if seed is not None else int(str(Env.next_seed())[:8])
    M = mt.count_rows()
    if cov_array != None:
        n_phens = cov_array.shape[0]
    else:
        n_phens = len(h2)
        if rg is None:
            print(f'Assuming rg=0 for all {n_phens} traits')
            rg = [0]*int((n_phens**2-n_phens)/2)
        cov_array = create_cov_array(h2, rg)
    cov_array = (1/M)*cov_array
    randstate = np.random.RandomState(int(seed)) #seed random state for replicability
    betas = randstate.multivariate_normal(mean=np.zeros(n_phens),cov=cov_array,size=[M,])
    df = pd.DataFrame([0]*M,columns=['beta'])
    tb = hl.Table.from_pandas(df)
    tb = tb.add_index().key_by('idx')
    tb = tb.annotate(beta = hl.literal(betas.tolist())[hl.int32(tb.idx)])
    mt = mt.add_row_index()
    mt = mt.annotate_rows(beta = tb[mt.row_idx]['beta'])
    return mt

def create_cov_array(h2_ls, rg_ls):
    n_rg = len(rg_ls)
    n_h2 = len(h2_ls)
    exp_n_rg = int((n_h2**2-n_h2)/2)
    if n_rg is not exp_n_rg:
        raise ValueError(f'The number of rg values given is {n_rg}, expected {exp_n_rg}')
    rg_ls = np.asarray(rg_ls)
    cov_array = np.zeros(shape=[n_h2,n_h2])
    cov_array[np.triu_indices(n_h2, k=1)] = rg_ls**2 #sets upper diagonal with covariances
    h2_diag = np.diag(h2_ls)
    cov_array = (np.matmul(np.matmul(cov_array,h2_diag).T,h2_diag)**(1/2))
    cov_array += cov_array.T + h2_diag
    return cov_array

@typecheck(mt=MatrixTable,
           genotype=expr_int32,
           beta=oneof(expr_float64,
                      expr_array(expr_float64)),
           h2=nullable(oneof(float,
                             int,
                             list)),
           popstrat=nullable(expr_int32))
def calculate_phenotypes(mt, genotype, beta, h2, popstrat=None):
    tid = ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase, k=5)) # "temporary id" -- random string to identify temporary intermediate fields generated by this method
    mt = mt._annotate_all(row_exprs={'beta_'+tid:beta},
                          entry_exprs={'gt_'+tid:genotype})
    mt = normalize_genotypes(mt, mt['gt_'+tid])
    if mt['beta_'+tid].dtype == dtype('array<float64>'):
        mt = mt.annotate_cols(y_no_noise = hl.agg.array_agg(lambda beta: hl.agg.sum(beta*mt['norm_gt']),mt['beta_'+tid]))
        mt = mt.annotate_cols(y = mt.y_no_noise + hl.literal(h2).map(lambda x: hl.rand_norm(0,hl.sqrt(1-x))))
    else:
        mt = mt.annotate_cols(y_no_noise = hl.agg.sum(mt['beta_'+tid] * mt['norm_gt']))
        mt = mt.annotate_cols(y = mt)
    mt = clean_fields(mt, tid)
    return mt
    
def normalize_genotypes(mt, genotypes):
    tid = ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase, k=5)) # "temporary id" -- random string to identify temporary intermediate fields generated by this method
    mt = mt.annotate_entries(**{'gt_'+tid: genotypes})
    mt = mt.annotate_rows(**{'gt_stats_'+tid: hl.agg.stats(mt['gt_'+tid])})
    mt = mt.annotate_entries(norm_gt = (mt['gt_'+tid]-mt['gt_stats_'+tid].mean)/mt['gt_stats_'+tid].stdev)  
    mt = clean_fields(mt, tid)
    return mt

def clean_fields(mt, str_expr):
    '''Removes fields with names that have str_expr in them'''
    all_fields = list(mt.col)+list(mt.row)+list(mt.entry)+list(mt.globals)
    return mt.drop(*(x for x in all_fields if str_expr in x))

